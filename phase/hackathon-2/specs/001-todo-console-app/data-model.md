# Data Model: Todo In-Memory Python Console App

**Feature**: 001-todo-console-app
**Date**: 2025-12-07
**Phase**: Phase 1 - Data Modeling

## Overview

This document defines the data entities, their relationships, validation rules, and state transitions for the todo application. All models support Constitutional Principle IV (Evolutionary Architecture) through clear interfaces that enable Phase II database swap.

---

## Entity: TaskStatus

**Type**: Enumeration

**Purpose**: Represents the completion state of a task

**Values**:
- `PENDING`: Task not yet completed (default state)
- `COMPLETED`: Task marked as done

**Validation Rules**:
- MUST be one of the two defined values
- Cannot be null or undefined

**State Transitions**:
```
PENDING ←→ COMPLETED (bidirectional toggle)
```

**Rationale**:
- FR-013: Use enumeration types for task status
- Prevents invalid states (e.g., "InProgress", "Cancelled")
- Type-safe (mypy enforces)

**Implementation Notes**:
- Python: `enum.Enum` or `typing.Literal["PENDING", "COMPLETED"]`
- Serialization: String representation for display
- Default: `PENDING` for new tasks

---

## Entity: Task

**Purpose**: Represents a single todo item with unique identifier, descriptive text, and completion status

### Attributes

| Attribute | Type | Required | Constraints | Default |
|-----------|------|----------|-------------|---------|
| `id` | `int` | Yes | Positive integer, unique, auto-generated | Auto-assigned by repository |
| `title` | `str` | Yes | Non-empty, max 200 characters | None (must be provided) |
| `description` | `str` | No | Max 1000 characters | Empty string |
| `status` | `TaskStatus` | Yes | PENDING or COMPLETED | PENDING |

### Validation Rules

1. **ID**:
   - MUST be unique across all tasks
   - MUST be positive integer (>= 1)
   - MUST be immutable after creation (FR-005, FR-006)
   - Auto-generated by repository using max(existing_ids) + 1

2. **Title**:
   - MUST NOT be empty string (FR-002)
   - MUST NOT be whitespace-only (edge case: whitespace-only titles)
   - Max length: 200 characters (spec assumption)
   - Required for creation; optional for update (partial updates allowed)

3. **Description**:
   - Optional field (can be empty string)
   - Max length: 1000 characters (spec assumption)
   - Empty string allowed and distinct from None

4. **Status**:
   - MUST be valid TaskStatus enum value
   - Cannot be null
   - Defaults to PENDING on creation

### Relationships

**No direct relationships** - Tasks are independent entities (flat structure, no hierarchy or dependencies)

### State Transitions

```
Task Lifecycle:

1. Creation:
   title="X", description="Y", status=PENDING → id=auto, status=PENDING

2. Update (FR-014):
   Any field except ID can be modified
   title: "X" → "Y" (preserves ID and status)
   description: "A" → "B" (preserves ID and status)
   status: unchanged during update

3. Toggle (FR-012):
   PENDING → COMPLETED
   COMPLETED → PENDING
   (preserves ID, title, description)

4. Deletion (FR-015):
   Task removed from storage
   ID not reused (next task continues sequence)
```

### Invariants

- ID uniqueness: No two active tasks can have same ID
- ID immutability: Once assigned, ID never changes
- ID sequence: Deleted IDs are not reused; sequence always increments
- Title requirement: Active task always has non-empty title
- Status validity: Status is always valid enum value

### Business Rules

1. **Creation** (FR-008):
   - Title is mandatory
   - Description is optional (defaults to empty)
   - Status is always PENDING initially
   - ID is auto-assigned by repository

2. **Update** (FR-014):
   - Can update title and/or description
   - Cannot update ID (immutable)
   - Cannot update status via update (use toggle instead)
   - Empty description on update = no change (edge case)

3. **Toggle** (FR-012):
   - Only affects status field
   - Bidirectional: PENDING ↔ COMPLETED
   - All other fields preserved

4. **Deletion** (FR-015):
   - Task removed completely
   - ID not reused (next_id counter continues)

---

## Entity: TaskRepositoryProtocol

**Type**: Interface (Python Protocol)

**Purpose**: Defines contract for task storage and retrieval, enabling Phase I (in-memory) to Phase II (PostgreSQL) swap without changing business logic

### Methods

#### 1. `add(task: Task) -> Task`

**Purpose**: Add new task with auto-generated ID

**Parameters**:
- `task`: Task instance with title, description, status (no ID yet)

**Returns**:
- Task instance with ID assigned

**Behavior**:
- Generate unique ID using max(existing_ids) + 1
- Assign ID to task
- Store task
- Return task with ID

**Raises**:
- `ValidationError` if task data invalid (title empty)

**Postconditions**:
- Task is retrievable via `get_by_id`
- ID sequence incremented
- Task appears in `get_all()` results

---

#### 2. `get_all() -> list[Task]`

**Purpose**: Retrieve all tasks sorted by ID (ascending)

**Parameters**: None

**Returns**:
- List of all tasks, sorted by ID (1, 2, 3, ...)
- Empty list if no tasks exist

**Behavior**:
- Query all stored tasks
- Sort by ID ascending (FR-011)
- Return list (may be empty)

**Performance**:
- MUST complete in under 1 second for 1000 tasks (SC-002)

---

#### 3. `get_by_id(task_id: int) -> Task | None`

**Purpose**: Retrieve specific task by ID

**Parameters**:
- `task_id`: Unique task identifier

**Returns**:
- Task instance if found
- `None` if not found

**Behavior**:
- Lookup task by ID
- Return None if ID doesn't exist

**Performance**:
- O(1) lookup (dict-based storage)

---

#### 4. `update(task_id: int, title: str | None = None, description: str | None = None) -> Task`

**Purpose**: Update task title and/or description

**Parameters**:
- `task_id`: Task to update
- `title`: New title (None = no change)
- `description`: New description (None = no change)

**Returns**:
- Updated task instance

**Behavior**:
- Validate task exists (raise NotFoundError if not)
- Validate title not empty if provided
- Update only provided fields
- Preserve ID and status

**Raises**:
- `NotFoundError` if task_id doesn't exist (FR-003)
- `ValidationError` if title empty (FR-002)

**Edge Cases**:
- Both None: No changes (returns existing task)
- Empty string for description: Sets description to empty (valid)
- Empty string for title: Raises ValidationError

---

#### 5. `delete(task_id: int) -> bool`

**Purpose**: Delete task by ID

**Parameters**:
- `task_id`: Task to delete

**Returns**:
- `True` if deleted
- `False` if task didn't exist

**Behavior**:
- Remove task from storage
- ID not reused (next_id continues)
- Return success status

**Postconditions**:
- `get_by_id(task_id)` returns None
- Task not in `get_all()` results
- next_id unchanged (sequence preserved)

---

#### 6. `toggle_status(task_id: int) -> Task`

**Purpose**: Toggle task between PENDING and COMPLETED

**Parameters**:
- `task_id`: Task to toggle

**Returns**:
- Updated task instance

**Behavior**:
- Validate task exists (raise NotFoundError if not)
- If PENDING → set to COMPLETED
- If COMPLETED → set to PENDING
- Preserve all other fields
- Return updated task

**Raises**:
- `NotFoundError` if task_id doesn't exist (FR-003)

---

## Storage Implementation: InMemoryTaskRepository

**Purpose**: Phase I concrete implementation of TaskRepositoryProtocol using in-memory Python dict

### Internal State

```python
_tasks: dict[int, Task]  # Key: task ID, Value: Task instance
_next_id: int            # Counter for next auto-generated ID
```

### Characteristics

- **Persistence**: None (data lost on exit per FR-007)
- **Concurrency**: Single-threaded (no locks needed per spec assumption)
- **Performance**: O(1) lookups, O(n) get_all with sort
- **Memory**: ~500KB for 1000 tasks (well under budget)

### ID Generation Algorithm

```
On add():
  new_id = _next_id
  task.id = new_id
  _tasks[new_id] = task
  _next_id += 1
  return task
```

**Guarantees**:
- Unique IDs (monotonically increasing)
- No ID reuse after deletion (counter never decrements)
- Thread-safe not required (single-user)

---

## Future Phase Compatibility

### Phase II: PostgreSQL Migration

**Interface Stability**: TaskRepositoryProtocol remains unchanged

**Implementation Swap**:
```
InMemoryTaskRepository → PostgreSQLTaskRepository

Changes:
- _tasks dict → PostgreSQL table
- _next_id counter → SERIAL or SEQUENCE
- get_all() → SELECT * ORDER BY id
- get_by_id() → SELECT WHERE id = ?
- add() → INSERT RETURNING
```

**Business Logic Impact**: Zero (service layer unchanged)

**Migration Path**:
1. Implement PostgreSQLTaskRepository matching protocol
2. Update dependency injection in app.py
3. Add SQLModel models with same field structure
4. No changes to TaskService or UI layers

**Constitutional Alignment**: Principle IV (Evolutionary Architecture) validated

---

## Validation Summary

| Requirement | Data Model Support |
|-------------|-------------------|
| FR-005: Auto-increment IDs | ✅ Repository auto-assigns via _next_id |
| FR-006: ID sequence preservation | ✅ Counter never decrements after deletion |
| FR-002: Non-empty titles | ✅ Validation rule enforced |
| FR-013: Status enum | ✅ TaskStatus enumeration |
| FR-016: Repository pattern | ✅ Protocol-based abstraction |
| FR-017: Strict typing | ✅ All attributes type-annotated |

---

## Appendix: Type Signatures

```python
from enum import Enum
from typing import Protocol

class TaskStatus(Enum):
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"

class Task:
    id: int
    title: str
    description: str
    status: TaskStatus

class TaskRepositoryProtocol(Protocol):
    def add(self, task: Task) -> Task: ...
    def get_all(self) -> list[Task]: ...
    def get_by_id(self, task_id: int) -> Task | None: ...
    def update(self, task_id: int, title: str | None = None,
               description: str | None = None) -> Task: ...
    def delete(self, task_id: int) -> bool: ...
    def toggle_status(self, task_id: int) -> Task: ...
```

*Note: Actual implementation will use Pydantic BaseModel for Task to leverage automatic validation*
